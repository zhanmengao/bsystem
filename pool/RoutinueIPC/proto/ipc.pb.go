// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ipc.proto

package proto

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type IPCHeader struct {
	PakId                IPCMessageID `protobuf:"varint,1,opt,name=PakId,proto3,enum=proto.IPCMessageID" json:"PakId"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *IPCHeader) Reset()         { *m = IPCHeader{} }
func (m *IPCHeader) String() string { return proto.CompactTextString(m) }
func (*IPCHeader) ProtoMessage()    {}
func (*IPCHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eb2dac662210585, []int{0}
}
func (m *IPCHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPCHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPCHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPCHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPCHeader.Merge(m, src)
}
func (m *IPCHeader) XXX_Size() int {
	return m.Size()
}
func (m *IPCHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_IPCHeader.DiscardUnknown(m)
}

var xxx_messageInfo_IPCHeader proto.InternalMessageInfo

func (m *IPCHeader) GetPakId() IPCMessageID {
	if m != nil {
		return m.PakId
	}
	return IPCMessageLoginEvent
}

type IPCMessage struct {
	Head                 *IPCHeader `protobuf:"bytes,1,opt,name=head,proto3" json:"head"`
	Data                 []byte     `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *IPCMessage) Reset()         { *m = IPCMessage{} }
func (m *IPCMessage) String() string { return proto.CompactTextString(m) }
func (*IPCMessage) ProtoMessage()    {}
func (*IPCMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eb2dac662210585, []int{1}
}
func (m *IPCMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IPCMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IPCMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IPCMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IPCMessage.Merge(m, src)
}
func (m *IPCMessage) XXX_Size() int {
	return m.Size()
}
func (m *IPCMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_IPCMessage.DiscardUnknown(m)
}

var xxx_messageInfo_IPCMessage proto.InternalMessageInfo

func (m *IPCMessage) GetHead() *IPCHeader {
	if m != nil {
		return m.Head
	}
	return nil
}

func (m *IPCMessage) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type UrvLoginEvent struct {
	UID                  string   `protobuf:"bytes,1,opt,name=UID,proto3" json:"UID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UrvLoginEvent) Reset()         { *m = UrvLoginEvent{} }
func (m *UrvLoginEvent) String() string { return proto.CompactTextString(m) }
func (*UrvLoginEvent) ProtoMessage()    {}
func (*UrvLoginEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eb2dac662210585, []int{2}
}
func (m *UrvLoginEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UrvLoginEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UrvLoginEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UrvLoginEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UrvLoginEvent.Merge(m, src)
}
func (m *UrvLoginEvent) XXX_Size() int {
	return m.Size()
}
func (m *UrvLoginEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_UrvLoginEvent.DiscardUnknown(m)
}

var xxx_messageInfo_UrvLoginEvent proto.InternalMessageInfo

func (m *UrvLoginEvent) GetUID() string {
	if m != nil {
		return m.UID
	}
	return ""
}

type UrvMoneyEvent struct {
	UID                  string   `protobuf:"bytes,1,opt,name=UID,proto3" json:"UID"`
	Incr                 int64    `protobuf:"varint,2,opt,name=Incr,proto3" json:"Incr"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UrvMoneyEvent) Reset()         { *m = UrvMoneyEvent{} }
func (m *UrvMoneyEvent) String() string { return proto.CompactTextString(m) }
func (*UrvMoneyEvent) ProtoMessage()    {}
func (*UrvMoneyEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eb2dac662210585, []int{3}
}
func (m *UrvMoneyEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UrvMoneyEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UrvMoneyEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UrvMoneyEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UrvMoneyEvent.Merge(m, src)
}
func (m *UrvMoneyEvent) XXX_Size() int {
	return m.Size()
}
func (m *UrvMoneyEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_UrvMoneyEvent.DiscardUnknown(m)
}

var xxx_messageInfo_UrvMoneyEvent proto.InternalMessageInfo

func (m *UrvMoneyEvent) GetUID() string {
	if m != nil {
		return m.UID
	}
	return ""
}

func (m *UrvMoneyEvent) GetIncr() int64 {
	if m != nil {
		return m.Incr
	}
	return 0
}

type UrvStealPoolReq struct {
	UID                  string   `protobuf:"bytes,1,opt,name=UID,proto3" json:"UID"`
	Need                 int32    `protobuf:"varint,2,opt,name=Need,proto3" json:"Need"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UrvStealPoolReq) Reset()         { *m = UrvStealPoolReq{} }
func (m *UrvStealPoolReq) String() string { return proto.CompactTextString(m) }
func (*UrvStealPoolReq) ProtoMessage()    {}
func (*UrvStealPoolReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eb2dac662210585, []int{4}
}
func (m *UrvStealPoolReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UrvStealPoolReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UrvStealPoolReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UrvStealPoolReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UrvStealPoolReq.Merge(m, src)
}
func (m *UrvStealPoolReq) XXX_Size() int {
	return m.Size()
}
func (m *UrvStealPoolReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UrvStealPoolReq.DiscardUnknown(m)
}

var xxx_messageInfo_UrvStealPoolReq proto.InternalMessageInfo

func (m *UrvStealPoolReq) GetUID() string {
	if m != nil {
		return m.UID
	}
	return ""
}

func (m *UrvStealPoolReq) GetNeed() int32 {
	if m != nil {
		return m.Need
	}
	return 0
}

type UrvStealPoolRspFriend struct {
	UID                  string   `protobuf:"bytes,1,opt,name=UID,proto3" json:"UID"`
	Money                int64    `protobuf:"varint,2,opt,name=Money,proto3" json:"Money"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UrvStealPoolRspFriend) Reset()         { *m = UrvStealPoolRspFriend{} }
func (m *UrvStealPoolRspFriend) String() string { return proto.CompactTextString(m) }
func (*UrvStealPoolRspFriend) ProtoMessage()    {}
func (*UrvStealPoolRspFriend) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eb2dac662210585, []int{5}
}
func (m *UrvStealPoolRspFriend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UrvStealPoolRspFriend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UrvStealPoolRspFriend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UrvStealPoolRspFriend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UrvStealPoolRspFriend.Merge(m, src)
}
func (m *UrvStealPoolRspFriend) XXX_Size() int {
	return m.Size()
}
func (m *UrvStealPoolRspFriend) XXX_DiscardUnknown() {
	xxx_messageInfo_UrvStealPoolRspFriend.DiscardUnknown(m)
}

var xxx_messageInfo_UrvStealPoolRspFriend proto.InternalMessageInfo

func (m *UrvStealPoolRspFriend) GetUID() string {
	if m != nil {
		return m.UID
	}
	return ""
}

func (m *UrvStealPoolRspFriend) GetMoney() int64 {
	if m != nil {
		return m.Money
	}
	return 0
}

type UrvStealPoolRsp struct {
	UID                  string                   `protobuf:"bytes,1,opt,name=UID,proto3" json:"UID"`
	FriendList           []*UrvStealPoolRspFriend `protobuf:"bytes,2,rep,name=friendList,proto3" json:"friendList"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *UrvStealPoolRsp) Reset()         { *m = UrvStealPoolRsp{} }
func (m *UrvStealPoolRsp) String() string { return proto.CompactTextString(m) }
func (*UrvStealPoolRsp) ProtoMessage()    {}
func (*UrvStealPoolRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eb2dac662210585, []int{6}
}
func (m *UrvStealPoolRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UrvStealPoolRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UrvStealPoolRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UrvStealPoolRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UrvStealPoolRsp.Merge(m, src)
}
func (m *UrvStealPoolRsp) XXX_Size() int {
	return m.Size()
}
func (m *UrvStealPoolRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_UrvStealPoolRsp.DiscardUnknown(m)
}

var xxx_messageInfo_UrvStealPoolRsp proto.InternalMessageInfo

func (m *UrvStealPoolRsp) GetUID() string {
	if m != nil {
		return m.UID
	}
	return ""
}

func (m *UrvStealPoolRsp) GetFriendList() []*UrvStealPoolRspFriend {
	if m != nil {
		return m.FriendList
	}
	return nil
}

type UrvStealEvent struct {
	SrcUID               string   `protobuf:"bytes,1,opt,name=SrcUID,proto3" json:"SrcUID"`
	DstUID               string   `protobuf:"bytes,2,opt,name=DstUID,proto3" json:"DstUID"`
	Money                int64    `protobuf:"varint,3,opt,name=Money,proto3" json:"Money"`
	EventTime            int64    `protobuf:"varint,4,opt,name=EventTime,proto3" json:"EventTime"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UrvStealEvent) Reset()         { *m = UrvStealEvent{} }
func (m *UrvStealEvent) String() string { return proto.CompactTextString(m) }
func (*UrvStealEvent) ProtoMessage()    {}
func (*UrvStealEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eb2dac662210585, []int{7}
}
func (m *UrvStealEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UrvStealEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UrvStealEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UrvStealEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UrvStealEvent.Merge(m, src)
}
func (m *UrvStealEvent) XXX_Size() int {
	return m.Size()
}
func (m *UrvStealEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_UrvStealEvent.DiscardUnknown(m)
}

var xxx_messageInfo_UrvStealEvent proto.InternalMessageInfo

func (m *UrvStealEvent) GetSrcUID() string {
	if m != nil {
		return m.SrcUID
	}
	return ""
}

func (m *UrvStealEvent) GetDstUID() string {
	if m != nil {
		return m.DstUID
	}
	return ""
}

func (m *UrvStealEvent) GetMoney() int64 {
	if m != nil {
		return m.Money
	}
	return 0
}

func (m *UrvStealEvent) GetEventTime() int64 {
	if m != nil {
		return m.EventTime
	}
	return 0
}

type UrvLockEvent struct {
	SrcUID               string   `protobuf:"bytes,1,opt,name=SrcUID,proto3" json:"SrcUID"`
	DstUID               string   `protobuf:"bytes,2,opt,name=DstUID,proto3" json:"DstUID"`
	EventTime            int64    `protobuf:"varint,3,opt,name=EventTime,proto3" json:"EventTime"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UrvLockEvent) Reset()         { *m = UrvLockEvent{} }
func (m *UrvLockEvent) String() string { return proto.CompactTextString(m) }
func (*UrvLockEvent) ProtoMessage()    {}
func (*UrvLockEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6eb2dac662210585, []int{8}
}
func (m *UrvLockEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UrvLockEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UrvLockEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UrvLockEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UrvLockEvent.Merge(m, src)
}
func (m *UrvLockEvent) XXX_Size() int {
	return m.Size()
}
func (m *UrvLockEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_UrvLockEvent.DiscardUnknown(m)
}

var xxx_messageInfo_UrvLockEvent proto.InternalMessageInfo

func (m *UrvLockEvent) GetSrcUID() string {
	if m != nil {
		return m.SrcUID
	}
	return ""
}

func (m *UrvLockEvent) GetDstUID() string {
	if m != nil {
		return m.DstUID
	}
	return ""
}

func (m *UrvLockEvent) GetEventTime() int64 {
	if m != nil {
		return m.EventTime
	}
	return 0
}

func init() {
	proto.RegisterType((*IPCHeader)(nil), "proto.IPCHeader")
	proto.RegisterType((*IPCMessage)(nil), "proto.IPCMessage")
	proto.RegisterType((*UrvLoginEvent)(nil), "proto.UrvLoginEvent")
	proto.RegisterType((*UrvMoneyEvent)(nil), "proto.UrvMoneyEvent")
	proto.RegisterType((*UrvStealPoolReq)(nil), "proto.UrvStealPoolReq")
	proto.RegisterType((*UrvStealPoolRspFriend)(nil), "proto.UrvStealPoolRspFriend")
	proto.RegisterType((*UrvStealPoolRsp)(nil), "proto.UrvStealPoolRsp")
	proto.RegisterType((*UrvStealEvent)(nil), "proto.UrvStealEvent")
	proto.RegisterType((*UrvLockEvent)(nil), "proto.UrvLockEvent")
}

func init() { proto.RegisterFile("ipc.proto", fileDescriptor_6eb2dac662210585) }

var fileDescriptor_6eb2dac662210585 = []byte{
	// 380 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x51, 0xcd, 0xae, 0xd2, 0x40,
	0x14, 0xa6, 0x94, 0x92, 0xf4, 0x80, 0x4a, 0xea, 0x4f, 0x1a, 0x42, 0x1a, 0x9c, 0xb8, 0xc0, 0x0d,
	0x0b, 0x8c, 0xba, 0x31, 0x31, 0x91, 0x4a, 0x6c, 0x02, 0xa6, 0x19, 0x64, 0xe7, 0x66, 0x6c, 0x47,
	0x6c, 0x80, 0xb6, 0xce, 0x0c, 0x24, 0xbe, 0xa1, 0x4b, 0x1e, 0x41, 0xbb, 0xba, 0xcb, 0xfb, 0x08,
	0x37, 0x3d, 0x43, 0x52, 0x20, 0xbd, 0x9b, 0xbb, 0xea, 0x39, 0xdf, 0x7c, 0x3f, 0x27, 0x5f, 0xc1,
	0x4e, 0xf2, 0x68, 0x9c, 0x8b, 0x4c, 0x65, 0x8e, 0x85, 0x9f, 0x3e, 0xf0, 0x74, 0xbf, 0xd3, 0x50,
	0xbf, 0x2b, 0x95, 0xd8, 0x47, 0x4a, 0x6f, 0xe4, 0x1d, 0xd8, 0x41, 0x38, 0xfd, 0xc2, 0x59, 0xcc,
	0x85, 0xf3, 0x1a, 0xac, 0x90, 0x6d, 0x82, 0xd8, 0x35, 0x86, 0xc6, 0xe8, 0xf1, 0xe4, 0xa9, 0xe6,
	0x8c, 0x83, 0x70, 0xba, 0xe0, 0x52, 0xb2, 0x35, 0x0f, 0x7c, 0xaa, 0x19, 0x64, 0x06, 0x50, 0xc1,
	0xce, 0x2b, 0x68, 0xfd, 0xe2, 0x4c, 0xeb, 0x3a, 0x93, 0x5e, 0xa5, 0xd3, 0xc6, 0x14, 0x5f, 0x1d,
	0x07, 0x5a, 0x3e, 0x53, 0xcc, 0x6d, 0x0e, 0x8d, 0x51, 0x97, 0xe2, 0x4c, 0x5e, 0xc2, 0xa3, 0x95,
	0x38, 0xcc, 0xb3, 0x75, 0x92, 0x7e, 0x3e, 0xf0, 0x54, 0x39, 0x3d, 0x30, 0x57, 0x81, 0x8f, 0x4e,
	0x36, 0x2d, 0x47, 0xf2, 0x16, 0x29, 0x8b, 0x2c, 0xe5, 0x7f, 0xee, 0xa1, 0x94, 0xce, 0x41, 0x1a,
	0x09, 0x74, 0x36, 0x29, 0xce, 0xe4, 0x3d, 0x3c, 0x59, 0x89, 0xc3, 0x52, 0x71, 0xb6, 0x0d, 0xb3,
	0x6c, 0x4b, 0xf9, 0xef, 0x7a, 0xe1, 0x57, 0xce, 0x63, 0x14, 0x5a, 0x14, 0x67, 0xf2, 0x11, 0x9e,
	0x5f, 0x08, 0x65, 0x3e, 0x13, 0x09, 0x4f, 0xe3, 0x1a, 0xf9, 0x33, 0xb0, 0xf0, 0xae, 0x53, 0xb0,
	0x5e, 0x08, 0xbb, 0x4a, 0x96, 0x79, 0x8d, 0xf4, 0x03, 0xc0, 0x4f, 0xb4, 0x9d, 0x27, 0x52, 0xb9,
	0xcd, 0xa1, 0x39, 0xea, 0x4c, 0x06, 0xa7, 0xe2, 0x6a, 0xe3, 0xe9, 0x19, 0x9f, 0x48, 0xec, 0x04,
	0x49, 0xba, 0x93, 0x17, 0xd0, 0x5e, 0x8a, 0xa8, 0xca, 0x38, 0x6d, 0x25, 0xee, 0x4b, 0x55, 0xe2,
	0x4d, 0x8d, 0xeb, 0xad, 0xba, 0xdc, 0x3c, 0xbb, 0xdc, 0x19, 0x80, 0x8d, 0x76, 0xdf, 0x92, 0x1d,
	0x77, 0x5b, 0xf8, 0x52, 0x01, 0xe4, 0x3b, 0x74, 0xf1, 0x5f, 0x45, 0x9b, 0x87, 0x65, 0x5e, 0xb8,
	0x9b, 0x57, 0xee, 0x9f, 0xdc, 0xe3, 0x7f, 0xaf, 0xf1, 0xb7, 0xf0, 0x8c, 0x63, 0xe1, 0x19, 0xff,
	0x0a, 0xcf, 0xb8, 0x29, 0xbc, 0xc6, 0x6d, 0xe1, 0x19, 0x3f, 0xda, 0xd8, 0xca, 0x9b, 0xbb, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xe5, 0x53, 0x66, 0x09, 0xd8, 0x02, 0x00, 0x00,
}

func (m *IPCHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPCHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPCHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PakId != 0 {
		i = encodeVarintIpc(dAtA, i, uint64(m.PakId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IPCMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IPCMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IPCMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintIpc(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Head != nil {
		{
			size, err := m.Head.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintIpc(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UrvLoginEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UrvLoginEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UrvLoginEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.UID) > 0 {
		i -= len(m.UID)
		copy(dAtA[i:], m.UID)
		i = encodeVarintIpc(dAtA, i, uint64(len(m.UID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UrvMoneyEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UrvMoneyEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UrvMoneyEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Incr != 0 {
		i = encodeVarintIpc(dAtA, i, uint64(m.Incr))
		i--
		dAtA[i] = 0x10
	}
	if len(m.UID) > 0 {
		i -= len(m.UID)
		copy(dAtA[i:], m.UID)
		i = encodeVarintIpc(dAtA, i, uint64(len(m.UID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UrvStealPoolReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UrvStealPoolReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UrvStealPoolReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Need != 0 {
		i = encodeVarintIpc(dAtA, i, uint64(m.Need))
		i--
		dAtA[i] = 0x10
	}
	if len(m.UID) > 0 {
		i -= len(m.UID)
		copy(dAtA[i:], m.UID)
		i = encodeVarintIpc(dAtA, i, uint64(len(m.UID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UrvStealPoolRspFriend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UrvStealPoolRspFriend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UrvStealPoolRspFriend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Money != 0 {
		i = encodeVarintIpc(dAtA, i, uint64(m.Money))
		i--
		dAtA[i] = 0x10
	}
	if len(m.UID) > 0 {
		i -= len(m.UID)
		copy(dAtA[i:], m.UID)
		i = encodeVarintIpc(dAtA, i, uint64(len(m.UID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UrvStealPoolRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UrvStealPoolRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UrvStealPoolRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FriendList) > 0 {
		for iNdEx := len(m.FriendList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FriendList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintIpc(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.UID) > 0 {
		i -= len(m.UID)
		copy(dAtA[i:], m.UID)
		i = encodeVarintIpc(dAtA, i, uint64(len(m.UID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UrvStealEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UrvStealEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UrvStealEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EventTime != 0 {
		i = encodeVarintIpc(dAtA, i, uint64(m.EventTime))
		i--
		dAtA[i] = 0x20
	}
	if m.Money != 0 {
		i = encodeVarintIpc(dAtA, i, uint64(m.Money))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DstUID) > 0 {
		i -= len(m.DstUID)
		copy(dAtA[i:], m.DstUID)
		i = encodeVarintIpc(dAtA, i, uint64(len(m.DstUID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SrcUID) > 0 {
		i -= len(m.SrcUID)
		copy(dAtA[i:], m.SrcUID)
		i = encodeVarintIpc(dAtA, i, uint64(len(m.SrcUID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UrvLockEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UrvLockEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UrvLockEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EventTime != 0 {
		i = encodeVarintIpc(dAtA, i, uint64(m.EventTime))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DstUID) > 0 {
		i -= len(m.DstUID)
		copy(dAtA[i:], m.DstUID)
		i = encodeVarintIpc(dAtA, i, uint64(len(m.DstUID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SrcUID) > 0 {
		i -= len(m.SrcUID)
		copy(dAtA[i:], m.SrcUID)
		i = encodeVarintIpc(dAtA, i, uint64(len(m.SrcUID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintIpc(dAtA []byte, offset int, v uint64) int {
	offset -= sovIpc(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *IPCHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PakId != 0 {
		n += 1 + sovIpc(uint64(m.PakId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IPCMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Head != nil {
		l = m.Head.Size()
		n += 1 + l + sovIpc(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovIpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UrvLoginEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UID)
	if l > 0 {
		n += 1 + l + sovIpc(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UrvMoneyEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UID)
	if l > 0 {
		n += 1 + l + sovIpc(uint64(l))
	}
	if m.Incr != 0 {
		n += 1 + sovIpc(uint64(m.Incr))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UrvStealPoolReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UID)
	if l > 0 {
		n += 1 + l + sovIpc(uint64(l))
	}
	if m.Need != 0 {
		n += 1 + sovIpc(uint64(m.Need))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UrvStealPoolRspFriend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UID)
	if l > 0 {
		n += 1 + l + sovIpc(uint64(l))
	}
	if m.Money != 0 {
		n += 1 + sovIpc(uint64(m.Money))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UrvStealPoolRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UID)
	if l > 0 {
		n += 1 + l + sovIpc(uint64(l))
	}
	if len(m.FriendList) > 0 {
		for _, e := range m.FriendList {
			l = e.Size()
			n += 1 + l + sovIpc(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UrvStealEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SrcUID)
	if l > 0 {
		n += 1 + l + sovIpc(uint64(l))
	}
	l = len(m.DstUID)
	if l > 0 {
		n += 1 + l + sovIpc(uint64(l))
	}
	if m.Money != 0 {
		n += 1 + sovIpc(uint64(m.Money))
	}
	if m.EventTime != 0 {
		n += 1 + sovIpc(uint64(m.EventTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UrvLockEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SrcUID)
	if l > 0 {
		n += 1 + l + sovIpc(uint64(l))
	}
	l = len(m.DstUID)
	if l > 0 {
		n += 1 + l + sovIpc(uint64(l))
	}
	if m.EventTime != 0 {
		n += 1 + sovIpc(uint64(m.EventTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovIpc(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozIpc(x uint64) (n int) {
	return sovIpc(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *IPCHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPCHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPCHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PakId", wireType)
			}
			m.PakId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PakId |= IPCMessageID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPCMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPCMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPCMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Head == nil {
				m.Head = &IPCHeader{}
			}
			if err := m.Head.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthIpc
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthIpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UrvLoginEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UrvLoginEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UrvLoginEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UrvMoneyEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UrvMoneyEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UrvMoneyEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incr", wireType)
			}
			m.Incr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Incr |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UrvStealPoolReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UrvStealPoolReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UrvStealPoolReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Need", wireType)
			}
			m.Need = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Need |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UrvStealPoolRspFriend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UrvStealPoolRspFriend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UrvStealPoolRspFriend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UrvStealPoolRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UrvStealPoolRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UrvStealPoolRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthIpc
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthIpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FriendList = append(m.FriendList, &UrvStealPoolRspFriend{})
			if err := m.FriendList[len(m.FriendList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipIpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UrvStealEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UrvStealEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UrvStealEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventTime", wireType)
			}
			m.EventTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UrvLockEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowIpc
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UrvLockEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UrvLockEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthIpc
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthIpc
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DstUID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventTime", wireType)
			}
			m.EventTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowIpc
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipIpc(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthIpc
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipIpc(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowIpc
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowIpc
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthIpc
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupIpc
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthIpc
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthIpc        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowIpc          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupIpc = fmt.Errorf("proto: unexpected end of group")
)
