1.C++的成员函数，相当于在C结构体里声明几个函数指针成员。
2.C++继承，相当于将基类放在子类的第一个成员（保证基类占的内存在前面）。
3.C++多态，在C中实现于，在继承的继承上，传给函数基类指针，经基类指针强转得到子类指针。
4.C++泛型，在C中使用void*类型。

C/C++ 类和结构体的的区别：

1、结构体基本用在很多数据，需要一个结构体来封装这些数据。而类的话，是面向对象的思想，可以有很多接口让人调用，私有变量等外部不能调用，还有保护类型的变量。

2、结构体也可以被认为是一种特殊的类，它不存在任何函数，构造和析构函数也没有，而且是一个公共的的类。

3、结构体在默认情况下成员是公共的（public），类在默认情况下成员是私有的(private)。

4、C++结构体内部成员变量及成员函数默认的访问级别是public，而c++类的内部成员变量及成员函数的默认访问级别是private。

5、C++结构体的继承默认是public，而c++类的继承默认是private。

6、类要加上public变成共有的才能被访问，而结构本身就是共有的可直接访问。

7、C定义结构体变量时需要加struct关键字，C++中定义结构体变量时可以不加struct关键字。

1.C++中 ,Union,Struct,Class的异同点
答：struct和class区别:在struct中,默认的访问级别是public,如果不特别指定级别,则结构体中的数据和函数均为公共接口,而在class默认的访问级别是private,其余之时:struct和class是等价 !

Union 使用

union 也可以包括构造函数和变量
在union中，所有的共用体成员共用一个空间，并且同一时间只能储存其中一个成员变量的值。
当一个共用体被说明时, 编译程序自动地产生一个变量, 其长度为联合中最大的变量长度。比如说，最大长度是double数据类型，分配的内存空间就是double型的长度。由于union的资料成员共用一个内存空间，所以必须存取正确的成员才能正确的读取变量值，可以使用一个额外的变数或列举型态来记录最后一次使用空间的是哪个成员。
而且，union的成员不可以是静态的

对于struct,与Union不同，Struct中的成员可以同时存在，所有成员默认公有

在这三种结构中，只有Union不可以被继承，Struct和Class都可以被继承

2。深拷贝和浅拷贝的区别
很多时候在我们都不知道拷贝构造函数的情况下，传递对象给函数参数或者函数返回对象都能很好的进行，这是因为编译器会给我们自动产生一个拷贝构造函数，这就是“默认拷贝构造函数”，这个构造函数很简单，仅仅使用“老对象”的数据成员的值对“新对象”的数据成员一一进行赋值

浅拷贝
浅拷贝就是复制原对象的引用，两者指向同一个内存地址，而深拷贝就是新的内存地址，复制原来对象的数据到这个新的内存地址中去，也就是说，深拷贝结束后，存在两个内存空间储存着一样的数据。

3.new和malloc有什么异同
1.new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。
2. 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。
3. new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。
4. new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。
5. new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。 malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。
6. C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。
7. 内存区域 new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。
8. 最大的不同在于，new不仅分配一段内存，而且会调用构造函数，但是malloc则不会
9. 两者的资源都需要手动释放

4 C++标准库中的algorithm中的sort()排序函数是怎么实现的，用的 什么排序算法*

时间复杂度：n*lg(n)

实现原理：sort并不是简单的快速排序，它对普通的快速排序进行了优化，此外，它还结合了插入排序和推排序。系统会根据你的数据形式和数据量自动选择合适的排序方法，这并不是说它每次排序只选择一种方法，它是在一次完整排序中不同的情况选用不同方法，比如给一个数据量较大的数组排序，开始采用快速排序，分段递归，分段之后每一段的数据量达到一个较小值后它就不继续往下递归，而是选择插入排序，如果递归的太深，他会选择推排序。（当时我就不会还在那里瞎扯，劝大家以后不知道就说不知道）

5.如何实现高内聚低耦合
相关的概念 https://blog.csdn.net/kingscoming/article/details/78836229这里说的很详细

回答的时候就要以你的项目为例子，说明在你的团队内部是怎么应用这些方法的，比如你们类之间的接口啊什么的。
因人而异，不多说

6，计算机图形学中，颜色的处理是在fragment shader 中还是vertex shader中（很遗憾，我当时没有复习图形学）
片元着色器

7.算法题：
在不使用临时变量的情况下，交换两个int变量的值
答：a=a+b;
b=a-b;
a=a-b;
正确答案
a=a^b;
b=a^b;
a=a^b;

那么这种算法，在什么情况下会有问题呢
答：当两个整数a，b的值得和超过了int类型的最大值，即65535的时候，该算法失效
问：那有没有更好的方法呢。（我就死在这里）
在我实在没有思路的时候
面试官给出了答案
只要对这两个数执行三次异或就可以交换两个变量的值
具体实现
a = a ^ b; b = b ^ a; a = a ^ b;

前两个赋值语句：“a = a ^ b；”和“b = b ^ a；”相当于b = b ^ (a ^ b)，而b ^ a ^ b等于a ^ b ^ b。b ^ b的结果为0，因为同一个数与相向相^，结果必为0。因此b的值等于a ^ 0，即a，其值为2。

再执行第三个赋值语句：“a = a ^ b”。由于a的值等于(a ^ b)，b的值等于(b ^ a ^ b)，因此，相当于a = a ^ b ^ b ^ a ^ b，即a的值等于a ^ a ^ b ^ b ^ b，等于b。

8.设计一个算法。判断一个多边形是凸多边形还是凹多边形。
答：多边形点集 = {P1,P2,P3,P4…Pn}
多边形所有点满足 点(Pn-3),点(Pn)在线段(Pn-2,Pn-1)的同侧
多边形是凸多边形，否则为凹多边形。
