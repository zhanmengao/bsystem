#include "Define.h"

/*
线程数量
std::thread::hardware_concurrency()函数返回一个程序中能够同时并发的线程数量，在多核系统中，其一般是核心数量。
但是这个函数仅仅是一个提示，当系统信息无法获取时，函数会返回0。

识别线程
线程标识类型是std::thread::id，可以通过两种方式进行检索。

通过调用std::thread对象的成员函数get_id()来直接获取。
当前线程中调用std::this_thread::get_id()也可以获得线程标识。
上面的方案和线程sleep很相似，使用上面一样的格式，get_id()函数替换成sleep()函数即可。
std::thread::id对象可以自由的拷贝和对比：

如果两个对象的std::thread::id相等，那它们就是同一个线程，或者都“没有线程”。
如果不等，那么就代表了两个不同线程，或者一个有线程，另一没有。
std::thread::id实例常用作检测特定线程是否需要进行一些操作，这常常用在某些线程需要执行特殊操作的场景，我们必须先要找出这些线程。


对于一个已经上锁的互斥量多次上锁，会出现未定义行为。然而对于嵌套锁std::recursive_mutex来说，多次上锁不会出现问题。

在互斥量锁住其他线程前,你必须释放你拥有的所有 锁,所以当你调用lock()三次时,你也必须调用unlock()三次。正确使
用 std::lock_guard<std::recursive_mutex>和 std::unique_lock<std::recursice_mutex>可以帮我们处理这些问题。

大多数情况下，嵌套锁是用在可被多线程并发访问的类上，所以其拥有一个互斥量保护其成员数据。
每个公共成员函数 都会对互斥量上锁,然后完成对应的功能,之后再解锁互斥量。
不过,有时一个公共成员函 数会调用另一个公共函数作为其操作的一部分。
不过上面提高的方案是不推荐的，推荐的做法是——从中提取出一个函数作为类的私有成员,
并且让所有成员函数都对其进行调用,这个私有成员函数不会对互斥量进行上锁(在调用前必 须获得锁)。
*/
void main()
{
	//mainPara();
	//mainMove();
	//MutexMain();
	//UniqueMutexMain();

	//mainLock();

	//MainCallOnce();

	MainOnceFlag();
}


